// Code generated by baron. DO NOT EDIT.
// Rerunning baron will overwrite this file.
// Version: v0.2.3-9-gbbc044f-dirty
// Version Date: 2020-10-29T13:36:14+08:00

package echo

// This file contains methods to make individual endpoints from services,
// request and response types to serve those endpoints, as well as encoders and
// decoders for those types, for all of our supported transport serialization
// formats.

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strconv"
	"strings"

	"github.com/go-kit/kit/endpoint"

	"github.com/gorilla/mux"
	"github.com/nats-io/nats.go"
	"github.com/pkg/errors"
	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"

	grpctransport "github.com/go-kit/kit/transport/grpc"
	httptransport "github.com/go-kit/kit/transport/http"
	natstransport "github.com/go-kit/kit/transport/nats"
)

var (
	_ = fmt.Sprint
	_ = bytes.Compare
	_ = strconv.Atoi
	_ = httptransport.NewServer
	_ = ioutil.NopCloser
	_ = io.Copy
	_ = errors.Wrap
)

/************************************** Endpoints ******************************************/

// In a server, it's useful for functions that need to operate on a per-endpoint
// basis. For example, you might pass an Endpoints to a function that produces
// an http.Handler, with each method (endpoint) wired up to a specific path. (It
// is probably a mistake in design to invoke the Service methods on the
// Endpoints struct in a server.)
//
// In a client, it's useful to collect individually constructed endpoints into a
// single type that implements the Service interface. For example, you might
// construct individual endpoints using transport/http.NewClient, combine them into an Endpoints, and return it to the caller as a Service.
type Endpoints struct {
	UnimplementedEchoServer

	EchoEndpoint endpoint.Endpoint

	LouderEndpoint endpoint.Endpoint

	LouderGetEndpoint endpoint.Endpoint
}

// Endpoints

func (e Endpoints) Echo(ctx context.Context, in *EchoRequest) (*EchoResponse, error) {
	response, err := e.EchoEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*EchoResponse), nil
}

func (e Endpoints) Louder(ctx context.Context, in *LouderRequest) (*EchoResponse, error) {
	response, err := e.LouderEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*EchoResponse), nil
}

func (e Endpoints) LouderGet(ctx context.Context, in *LouderRequest) (*EchoResponse, error) {
	response, err := e.LouderGetEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*EchoResponse), nil
}

// Make Endpoints

func MakeEchoEndpoint(s EchoServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*EchoRequest)
		v, err := s.Echo(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}
func MakeLouderEndpoint(s EchoServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*LouderRequest)
		v, err := s.Louder(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}
func MakeLouderGetEndpoint(s EchoServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*LouderRequest)
		v, err := s.LouderGet(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

// WrapAllExcept wraps each Endpoint field of struct Endpoints with a
// go-kit/kit/endpoint.Middleware.
// Use this for applying a set of middlewares to every endpoint in the service.
// Optionally, endpoints can be passed in by name to be excluded from being wrapped.
// WrapAllExcept(middleware, "Status", "Ping")
func (e *Endpoints) WrapAllExcept(middleware endpoint.Middleware, excluded ...string) {
	included := map[string]struct{}{
		"Echo":      {},
		"Louder":    {},
		"LouderGet": {},
	}

	for _, ex := range excluded {
		if _, ok := included[ex]; !ok {
			panic(fmt.Sprintf("Excluded endpoint '%s' does not exist; see middlewares/endpoints.go", ex))
		}
		delete(included, ex)
	}

	for inc := range included {
		if inc == "Echo" {
			e.EchoEndpoint = middleware(e.EchoEndpoint)
		}
		if inc == "Louder" {
			e.LouderEndpoint = middleware(e.LouderEndpoint)
		}
		if inc == "LouderGet" {
			e.LouderGetEndpoint = middleware(e.LouderGetEndpoint)
		}
	}
}

// LabeledMiddleware will get passed the endpoint name when passed to
// WrapAllLabeledExcept, this can be used to write a generic metrics
// middleware which can send the endpoint name to the metrics collector.
type LabeledMiddleware func(string, endpoint.Endpoint) endpoint.Endpoint

// WrapAllLabeledExcept wraps each Endpoint field of struct Endpoints with a
// LabeledMiddleware, which will receive the name of the endpoint. See
// LabeldMiddleware. See method WrapAllExept for details on excluded
// functionality.
func (e *Endpoints) WrapAllLabeledExcept(middleware func(string, endpoint.Endpoint) endpoint.Endpoint, excluded ...string) {
	included := map[string]struct{}{
		"Echo":      {},
		"Louder":    {},
		"LouderGet": {},
	}

	for _, ex := range excluded {
		if _, ok := included[ex]; !ok {
			panic(fmt.Sprintf("Excluded endpoint '%s' does not exist; see middlewares/endpoints.go", ex))
		}
		delete(included, ex)
	}

	for inc := range included {
		if inc == "Echo" {
			e.EchoEndpoint = middleware("Echo", e.EchoEndpoint)
		}
		if inc == "Louder" {
			e.LouderEndpoint = middleware("Louder", e.LouderEndpoint)
		}
		if inc == "LouderGet" {
			e.LouderGetEndpoint = middleware("LouderGet", e.LouderGetEndpoint)
		}
	}
}

/************************************** GRPCServer ******************************************/

// MakeGRPCServer makes a set of endpoints available as a gRPC EchoServer.
func MakeGRPCServer(endpoints Endpoints, options ...grpctransport.ServerOption) EchoServer {
	serverOptions := []grpctransport.ServerOption{
		grpctransport.ServerBefore(GRPCMetadataToContext),
	}
	serverOptions = append(serverOptions, options...)
	// echo
	return &grpcServer{

		echo: grpctransport.NewServer(
			endpoints.EchoEndpoint,
			DecodeGRPCEchoRequest,
			EncodeGRPCEchoResponse,
			serverOptions...,
		),
		louder: grpctransport.NewServer(
			endpoints.LouderEndpoint,
			DecodeGRPCLouderRequest,
			EncodeGRPCLouderResponse,
			serverOptions...,
		),
		louderget: grpctransport.NewServer(
			endpoints.LouderGetEndpoint,
			DecodeGRPCLouderGetRequest,
			EncodeGRPCLouderGetResponse,
			serverOptions...,
		),
	}
}

// grpcServer implements the EchoServer interface
type grpcServer struct {
	UnimplementedEchoServer

	echo      grpctransport.Handler
	louder    grpctransport.Handler
	louderget grpctransport.Handler
}

// Methods for grpcServer to implement EchoServer interface

func (s *grpcServer) Echo(ctx context.Context, req *EchoRequest) (*EchoResponse, error) {
	_, rep, err := s.echo.ServeGRPC(ctx, req)
	if err != nil {
		return nil, err
	}
	return rep.(*EchoResponse), nil
}

func (s *grpcServer) Louder(ctx context.Context, req *LouderRequest) (*EchoResponse, error) {
	_, rep, err := s.louder.ServeGRPC(ctx, req)
	if err != nil {
		return nil, err
	}
	return rep.(*EchoResponse), nil
}

func (s *grpcServer) LouderGet(ctx context.Context, req *LouderRequest) (*EchoResponse, error) {
	_, rep, err := s.louderget.ServeGRPC(ctx, req)
	if err != nil {
		return nil, err
	}
	return rep.(*EchoResponse), nil
}

// Server Decode

// DecodeGRPCEchoRequest is a transport/grpc.DecodeRequestFunc that converts a
// gRPC echo request to a user-domain echo request. Primarily useful in a server.
func DecodeGRPCEchoRequest(_ context.Context, grpcReq interface{}) (interface{}, error) {
	req := grpcReq.(*EchoRequest)
	return req, nil
}

// DecodeGRPCLouderRequest is a transport/grpc.DecodeRequestFunc that converts a
// gRPC louder request to a user-domain louder request. Primarily useful in a server.
func DecodeGRPCLouderRequest(_ context.Context, grpcReq interface{}) (interface{}, error) {
	req := grpcReq.(*LouderRequest)
	return req, nil
}

// DecodeGRPCLouderGetRequest is a transport/grpc.DecodeRequestFunc that converts a
// gRPC louderget request to a user-domain louderget request. Primarily useful in a server.
func DecodeGRPCLouderGetRequest(_ context.Context, grpcReq interface{}) (interface{}, error) {
	req := grpcReq.(*LouderRequest)
	return req, nil
}

// Server Encode

// EncodeGRPCEchoResponse is a transport/grpc.EncodeResponseFunc that converts a
// user-domain echo response to a gRPC echo reply. Primarily useful in a server.
func EncodeGRPCEchoResponse(_ context.Context, response interface{}) (interface{}, error) {
	resp := response.(*EchoResponse)
	return resp, nil
}

// EncodeGRPCLouderResponse is a transport/grpc.EncodeResponseFunc that converts a
// user-domain louder response to a gRPC louder reply. Primarily useful in a server.
func EncodeGRPCLouderResponse(_ context.Context, response interface{}) (interface{}, error) {
	resp := response.(*EchoResponse)
	return resp, nil
}

// EncodeGRPCLouderGetResponse is a transport/grpc.EncodeResponseFunc that converts a
// user-domain louderget response to a gRPC louderget reply. Primarily useful in a server.
func EncodeGRPCLouderGetResponse(_ context.Context, response interface{}) (interface{}, error) {
	resp := response.(*EchoResponse)
	return resp, nil
}

// Helpers

func GRPCMetadataToContext(ctx context.Context, md metadata.MD) context.Context {
	for k, v := range md {
		if v != nil {
			// The key is added both in metadata format (k) which is all lower
			// and the http.CanonicalHeaderKey of the key so that it can be
			// accessed in either format
			ctx = context.WithValue(ctx, k, v[0])
			ctx = context.WithValue(ctx, http.CanonicalHeaderKey(k), v[0])
		}
	}

	return ctx
}

/************************************** GRPCClient ******************************************/

// NewGRPCClient returns an service backed by a gRPC client connection. It is the
// responsibility of the caller to dial, and later close, the connection.
func NewGRPCClient(conn *grpc.ClientConn, options ...grpctransport.ClientOption) (EchoServer, error) {
	var echoEndpoint endpoint.Endpoint
	{
		echoEndpoint = grpctransport.NewClient(
			conn,
			"echo.Echo",
			"Echo",
			EncodeGRPCEchoRequest,
			DecodeGRPCEchoResponse,
			EchoResponse{},
			options...,
		).Endpoint()
	}

	var louderEndpoint endpoint.Endpoint
	{
		louderEndpoint = grpctransport.NewClient(
			conn,
			"echo.Echo",
			"Louder",
			EncodeGRPCLouderRequest,
			DecodeGRPCLouderResponse,
			EchoResponse{},
			options...,
		).Endpoint()
	}

	var loudergetEndpoint endpoint.Endpoint
	{
		loudergetEndpoint = grpctransport.NewClient(
			conn,
			"echo.Echo",
			"LouderGet",
			EncodeGRPCLouderGetRequest,
			DecodeGRPCLouderGetResponse,
			EchoResponse{},
			options...,
		).Endpoint()
	}

	return Endpoints{
		EchoEndpoint:      echoEndpoint,
		LouderEndpoint:    louderEndpoint,
		LouderGetEndpoint: loudergetEndpoint,
	}, nil
}

// GRPC Client Decode

// DecodeGRPCEchoResponse is a transport/grpc.DecodeResponseFunc that converts a
// gRPC echo reply to a user-domain echo response. Primarily useful in a client.
func DecodeGRPCEchoResponse(_ context.Context, grpcReply interface{}) (interface{}, error) {
	reply := grpcReply.(*EchoResponse)
	return reply, nil
}

// DecodeGRPCLouderResponse is a transport/grpc.DecodeResponseFunc that converts a
// gRPC louder reply to a user-domain louder response. Primarily useful in a client.
func DecodeGRPCLouderResponse(_ context.Context, grpcReply interface{}) (interface{}, error) {
	reply := grpcReply.(*EchoResponse)
	return reply, nil
}

// DecodeGRPCLouderGetResponse is a transport/grpc.DecodeResponseFunc that converts a
// gRPC louderget reply to a user-domain louderget response. Primarily useful in a client.
func DecodeGRPCLouderGetResponse(_ context.Context, grpcReply interface{}) (interface{}, error) {
	reply := grpcReply.(*EchoResponse)
	return reply, nil
}

// GRPC Client Encode

// EncodeGRPCEchoRequest is a transport/grpc.EncodeRequestFunc that converts a
// user-domain echo request to a gRPC echo request. Primarily useful in a client.
func EncodeGRPCEchoRequest(_ context.Context, request interface{}) (interface{}, error) {
	req := request.(*EchoRequest)
	return req, nil
}

// EncodeGRPCLouderRequest is a transport/grpc.EncodeRequestFunc that converts a
// user-domain louder request to a gRPC louder request. Primarily useful in a client.
func EncodeGRPCLouderRequest(_ context.Context, request interface{}) (interface{}, error) {
	req := request.(*LouderRequest)
	return req, nil
}

// EncodeGRPCLouderGetRequest is a transport/grpc.EncodeRequestFunc that converts a
// user-domain louderget request to a gRPC louderget request. Primarily useful in a client.
func EncodeGRPCLouderGetRequest(_ context.Context, request interface{}) (interface{}, error) {
	req := request.(*LouderRequest)
	return req, nil
}

// ContextValuesToGRPCMetadata is a grpctransport.ClientRequestFunc
func ContextValuesToGRPCMetadata(keys []string) grpctransport.ClientRequestFunc {
	return func(ctx context.Context, md *metadata.MD) context.Context {
		var pairs []string
		for _, k := range keys {
			if v, ok := ctx.Value(k).(string); ok {
				pairs = append(pairs, k, v)
			}
		}

		if pairs != nil {
			*md = metadata.Join(*md, metadata.Pairs(pairs...))
		}

		return ctx
	}
}

/************************************** HTTPServer ******************************************/

const contentType = "application/json; charset=utf-8"

// MakeHTTPHandler returns a handler that makes a set of endpoints available
// on predefined paths.
func MakeHTTPHandler(endpoints Endpoints, options ...httptransport.ServerOption) http.Handler {
	serverOptions := []httptransport.ServerOption{
		httptransport.ServerBefore(HTTPHeadersToContext),
		httptransport.ServerErrorEncoder(errorEncoder),
		httptransport.ServerAfter(httptransport.SetContentType(contentType)),
	}
	serverOptions = append(serverOptions, options...)
	m := mux.NewRouter()

	m.Methods("GET").Path("/echo/").Handler(httptransport.NewServer(
		endpoints.EchoEndpoint,
		DecodeHTTPEchoZeroRequest,
		EncodeHTTPGenericResponse,
		serverOptions...,
	))
	m.Methods("GET").Path("/echo").Handler(httptransport.NewServer(
		endpoints.EchoEndpoint,
		DecodeHTTPEchoOneRequest,
		EncodeHTTPGenericResponse,
		serverOptions...,
	))

	m.Methods("POST").Path("/louder/{loudness}").Handler(httptransport.NewServer(
		endpoints.LouderEndpoint,
		DecodeHTTPLouderZeroRequest,
		EncodeHTTPGenericResponse,
		serverOptions...,
	))
	m.Methods("HEAD").Path("/louder/{loudness}").Handler(httptransport.NewServer(
		endpoints.LouderEndpoint,
		DecodeHTTPLouderOneRequest,
		EncodeHTTPGenericResponse,
		serverOptions...,
	))

	m.Methods("GET").Path("/louder/{loudness}").Handler(httptransport.NewServer(
		endpoints.LouderGetEndpoint,
		DecodeHTTPLouderGetZeroRequest,
		EncodeHTTPGenericResponse,
		serverOptions...,
	))
	return m
}

// ErrorEncoder writes the error to the ResponseWriter, by default a content
// type of application/json, a body of json with key "error" and the value
// error.Error(), and a status code of 500. If the error implements Headerer,
// the provided headers will be applied to the response. If the error
// implements json.Marshaler, and the marshaling succeeds, the JSON encoded
// form of the error will be used. If the error implements StatusCoder, the
// provided StatusCode will be used instead of 500.
func errorEncoder(_ context.Context, err error, w http.ResponseWriter) {
	body, _ := json.Marshal(errorWrapper{Error: err.Error()})
	if marshaler, ok := err.(json.Marshaler); ok {
		if jsonBody, marshalErr := marshaler.MarshalJSON(); marshalErr == nil {
			body = jsonBody
		}
	}
	w.Header().Set("Content-Type", contentType)
	if headerer, ok := err.(httptransport.Headerer); ok {
		for k := range headerer.Headers() {
			w.Header().Set(k, headerer.Headers().Get(k))
		}
	}
	code := http.StatusInternalServerError
	if sc, ok := err.(httptransport.StatusCoder); ok {
		code = sc.StatusCode()
	}
	w.WriteHeader(code)
	w.Write(body)
}

func errorDecoder(buf []byte) error {
	var w errorWrapper
	if err := json.Unmarshal(buf, &w); err != nil {
		const size = 8196
		if len(buf) > size {
			buf = buf[:size]
		}
		return fmt.Errorf("response body '%s': cannot parse non-json request body", buf)
	}

	return errors.New(w.Error)
}

type errorWrapper struct {
	Error string `json:"error"`
}

// httpError satisfies the Headerer and StatusCoder interfaces in
// package github.com/go-kit/kit/transport/http.
type httpError struct {
	error
	statusCode int
	headers    map[string][]string
}

func (h httpError) StatusCode() int {
	return h.statusCode
}

func (h httpError) Headers() http.Header {
	return h.headers
}

// Server Decode

// DecodeHTTPEchoZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded echo request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPEchoZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req EchoRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		// unmarshaller := jsonpb.Unmarshaler{
		// 	AllowUnknownFields: true,
		// }
		unmarshaller := protojson.UnmarshalOptions{
			AllowPartial:   true,
			DiscardUnknown: true,
		}
		// if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
		if err = unmarshaller.Unmarshal(buf, &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if InEchoStrArr, ok := queryParams["in"]; ok {
		InEchoStr := InEchoStrArr[0]
		InEcho := InEchoStr
		req.In = InEcho
	}

	if AtEchoStrArr, ok := queryParams["at"]; ok {
		AtEchoStr := AtEchoStrArr[0]
		AtEcho, err := strconv.ParseInt(AtEchoStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting AtEcho from query, queryParams: %v", queryParams))
		}
		req.At = &AtEcho
	}

	if DescEchoStrArr, ok := queryParams["desc"]; ok {
		DescEchoStr := DescEchoStrArr[0]
		DescEcho := DescEchoStr
		req.Desc = &DescEcho
	}

	if DebugEchoStrArr, ok := queryParams["debug"]; ok {
		DebugEchoStr := DebugEchoStrArr[0]
		DebugEcho, err := strconv.ParseBool(DebugEchoStr)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting DebugEcho from query, queryParams: %v", queryParams))
		}
		req.Debug = &DebugEcho
	}

	return &req, err
}

// DecodeHTTPEchoOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded echo request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPEchoOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req EchoRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		// unmarshaller := jsonpb.Unmarshaler{
		// 	AllowUnknownFields: true,
		// }
		unmarshaller := protojson.UnmarshalOptions{
			AllowPartial:   true,
			DiscardUnknown: true,
		}
		// if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
		if err = unmarshaller.Unmarshal(buf, &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if InEchoStrArr, ok := queryParams["in"]; ok {
		InEchoStr := InEchoStrArr[0]
		InEcho := InEchoStr
		req.In = InEcho
	}

	if AtEchoStrArr, ok := queryParams["at"]; ok {
		AtEchoStr := AtEchoStrArr[0]
		AtEcho, err := strconv.ParseInt(AtEchoStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting AtEcho from query, queryParams: %v", queryParams))
		}
		req.At = &AtEcho
	}

	if DescEchoStrArr, ok := queryParams["desc"]; ok {
		DescEchoStr := DescEchoStrArr[0]
		DescEcho := DescEchoStr
		req.Desc = &DescEcho
	}

	if DebugEchoStrArr, ok := queryParams["debug"]; ok {
		DebugEchoStr := DebugEchoStrArr[0]
		DebugEcho, err := strconv.ParseBool(DebugEchoStr)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting DebugEcho from query, queryParams: %v", queryParams))
		}
		req.Debug = &DebugEcho
	}

	return &req, err
}

// DecodeHTTPLouderZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded louder request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPLouderZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req LouderRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		// unmarshaller := jsonpb.Unmarshaler{
		// 	AllowUnknownFields: true,
		// }
		unmarshaller := protojson.UnmarshalOptions{
			AllowPartial:   true,
			DiscardUnknown: true,
		}
		// if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
		if err = unmarshaller.Unmarshal(buf, &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	LoudnessLouderStr := pathParams["loudness"]
	LoudnessLouder, err := strconv.ParseInt(LoudnessLouderStr, 10, 32)
	if err != nil {
		return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting LoudnessLouder from path, pathParams: %v", pathParams))
	}
	req.Loudness = int32(LoudnessLouder)

	return &req, err
}

// DecodeHTTPLouderOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded louder request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPLouderOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req LouderRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		// unmarshaller := jsonpb.Unmarshaler{
		// 	AllowUnknownFields: true,
		// }
		unmarshaller := protojson.UnmarshalOptions{
			AllowPartial:   true,
			DiscardUnknown: true,
		}
		// if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
		if err = unmarshaller.Unmarshal(buf, &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if InLouderStrArr, ok := queryParams["in"]; ok {
		InLouderStr := InLouderStrArr[0]
		InLouder := InLouderStr
		req.In = InLouder
	}

	LoudnessLouderStr := pathParams["loudness"]
	LoudnessLouder, err := strconv.ParseInt(LoudnessLouderStr, 10, 32)
	if err != nil {
		return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting LoudnessLouder from path, pathParams: %v", pathParams))
	}
	req.Loudness = int32(LoudnessLouder)

	return &req, err
}

// DecodeHTTPLouderGetZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded louderget request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPLouderGetZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req LouderRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		// unmarshaller := jsonpb.Unmarshaler{
		// 	AllowUnknownFields: true,
		// }
		unmarshaller := protojson.UnmarshalOptions{
			AllowPartial:   true,
			DiscardUnknown: true,
		}
		// if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
		if err = unmarshaller.Unmarshal(buf, &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if InLouderGetStrArr, ok := queryParams["in"]; ok {
		InLouderGetStr := InLouderGetStrArr[0]
		InLouderGet := InLouderGetStr
		req.In = InLouderGet
	}

	LoudnessLouderGetStr := pathParams["loudness"]
	LoudnessLouderGet, err := strconv.ParseInt(LoudnessLouderGetStr, 10, 32)
	if err != nil {
		return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting LoudnessLouderGet from path, pathParams: %v", pathParams))
	}
	req.Loudness = int32(LoudnessLouderGet)

	return &req, err
}

// EncodeHTTPGenericResponse is a transport/http.EncodeResponseFunc that encodes
// the response as JSON to the response writer. Primarily useful in a server.
func EncodeHTTPGenericResponse(_ context.Context, w http.ResponseWriter, response interface{}) error {
	// marshaller := jsonpb.Marshaler{
	// 	EmitDefaults: true,
	// 	OrigName: true,
	// 	EnumsAsInts:  true,
	// }
	// return marshaller.Marshal(w, response.(proto.Message))
	marshaller := protojson.MarshalOptions{
		AllowPartial:    true,
		UseProtoNames:   false,
		UseEnumNumbers:  true,
		EmitUnpopulated: true,
	}
	buf, err := marshaller.Marshal(response.(proto.Message))
	if err != nil {
		return err
	}
	_, err = w.Write(buf)
	return err
}

// Helper functions

func HTTPHeadersToContext(ctx context.Context, r *http.Request) context.Context {
	for k := range r.Header {
		// The key is added both in http format (k) which has had
		// http.CanonicalHeaderKey called on it in transport as well as the
		// strings.ToLower which is the grpc metadata format of the key so
		// that it can be accessed in either format
		ctx = context.WithValue(ctx, k, r.Header.Get(k))
		ctx = context.WithValue(ctx, strings.ToLower(k), r.Header.Get(k))
	}

	// Tune specific change.
	// also add the request url
	ctx = context.WithValue(ctx, "request-url", r.URL.Path)
	ctx = context.WithValue(ctx, "transport", "HTTPJSON")

	return ctx
}

/************************************** HTTPClient ******************************************/

// NewHTTPClient returns a service backed by an HTTP server living at the remote
// instance. We expect instance to come from a service discovery system, so
// likely of the form "host:port".
func NewHTTPClient(instance string, options ...httptransport.ClientOption) (EchoServer, error) {
	if !strings.HasPrefix(instance, "http") {
		instance = "http://" + instance
	}
	u, err := url.Parse(instance)
	if err != nil {
		return nil, err
	}
	_ = u

	var EchoZeroEndpoint endpoint.Endpoint
	{
		EchoZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/echo/"),
			EncodeHTTPEchoZeroRequest,
			DecodeHTTPEchoResponse,
			options...,
		).Endpoint()
	}
	var LouderZeroEndpoint endpoint.Endpoint
	{
		LouderZeroEndpoint = httptransport.NewClient(
			"POST",
			copyURL(u, "/louder/"),
			EncodeHTTPLouderZeroRequest,
			DecodeHTTPLouderResponse,
			options...,
		).Endpoint()
	}
	var LouderGetZeroEndpoint endpoint.Endpoint
	{
		LouderGetZeroEndpoint = httptransport.NewClient(
			"GET",
			copyURL(u, "/louder/"),
			EncodeHTTPLouderGetZeroRequest,
			DecodeHTTPLouderGetResponse,
			options...,
		).Endpoint()
	}

	return Endpoints{
		EchoEndpoint:      EchoZeroEndpoint,
		LouderEndpoint:    LouderZeroEndpoint,
		LouderGetEndpoint: LouderGetZeroEndpoint,
	}, nil
}

func copyURL(base *url.URL, path string) *url.URL {
	next := *base
	next.Path = path
	return &next
}

// CtxValuesToSend configures the http client to pull the specified keys out of
// the context and add them to the http request as headers.  Note that keys
// will have net/http.CanonicalHeaderKey called on them before being send over
// the wire and that is the form they will be available in the server context.
func CtxValuesToSend(keys ...string) httptransport.ClientOption {
	return httptransport.ClientBefore(func(ctx context.Context, r *http.Request) context.Context {
		for _, k := range keys {
			if v, ok := ctx.Value(k).(string); ok {
				r.Header.Set(k, v)
			}
		}
		return ctx
	})
}

// HTTP Client Decode

// DecodeHTTPEchoResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded EchoResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPEchoResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp EchoResponse
	// if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
	// 	return nil, errorDecoder(buf)
	// }
	if err = protojson.Unmarshal(buf, &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPLouderResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded EchoResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPLouderResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp EchoResponse
	// if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
	// 	return nil, errorDecoder(buf)
	// }
	if err = protojson.Unmarshal(buf, &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// DecodeHTTPLouderGetResponse is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded EchoResponse response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTPLouderGetResponse(_ context.Context, r *http.Response) (interface{}, error) {
	defer r.Body.Close()
	buf, err := ioutil.ReadAll(r.Body)
	if err == io.EOF {
		return nil, errors.New("response http body empty")
	}
	if err != nil {
		return nil, errors.Wrap(err, "cannot read http body")
	}

	if r.StatusCode != http.StatusOK {
		return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
	}

	var resp EchoResponse
	// if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
	// 	return nil, errorDecoder(buf)
	// }
	if err = protojson.Unmarshal(buf, &resp); err != nil {
		return nil, errorDecoder(buf)
	}

	return &resp, nil
}

// HTTP Client Encode
// EncodeHTTPEchoZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a echo request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPEchoZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*EchoRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"echo",
		"",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("in", fmt.Sprint(req.In))

	if req.At != nil {
		values.Add("at", fmt.Sprint(*req.At))
	}

	if req.Desc != nil {
		values.Add("desc", fmt.Sprint(*req.Desc))
	}

	if req.Debug != nil {
		values.Add("debug", fmt.Sprint(*req.Debug))
	}

	r.URL.RawQuery = values.Encode()
	return nil
} // EncodeHTTPEchoOneRequest is a transport/http.EncodeRequestFunc
// that encodes a echo request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPEchoOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*EchoRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"echo",
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("in", fmt.Sprint(req.In))

	if req.At != nil {
		values.Add("at", fmt.Sprint(*req.At))
	}

	if req.Desc != nil {
		values.Add("desc", fmt.Sprint(*req.Desc))
	}

	if req.Debug != nil {
		values.Add("debug", fmt.Sprint(*req.Debug))
	}

	r.URL.RawQuery = values.Encode()
	return nil
} // EncodeHTTPLouderZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a louder request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPLouderZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*LouderRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"louder",
		fmt.Sprint(req.Loudness),
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*LouderRequest)

	toRet.In = req.In

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
} // EncodeHTTPLouderOneRequest is a transport/http.EncodeRequestFunc
// that encodes a louder request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPLouderOneRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*LouderRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"louder",
		fmt.Sprint(req.Loudness),
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("in", fmt.Sprint(req.In))

	r.URL.RawQuery = values.Encode()
	// Set the body parameters
	var buf bytes.Buffer
	toRet := request.(*LouderRequest)
	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)
	if err := encoder.Encode(toRet); err != nil {
		return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
} // EncodeHTTPLouderGetZeroRequest is a transport/http.EncodeRequestFunc
// that encodes a louderget request into the various portions of
// the http request (path, query, and body).
func EncodeHTTPLouderGetZeroRequest(_ context.Context, r *http.Request, request interface{}) error {
	strval := ""
	_ = strval
	req := request.(*LouderRequest)
	_ = req

	r.Header.Set("transport", "HTTPJSON")
	r.Header.Set("request-url", r.URL.Path)

	// Set the path parameters
	path := strings.Join([]string{
		"",
		"louder",
		fmt.Sprint(req.Loudness),
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return errors.Wrapf(err, "couldn't unmarshal path %q", path)
	}
	r.URL.RawPath = u.RawPath
	r.URL.Path = u.Path

	// Set the query parameters
	values := r.URL.Query()
	var tmp []byte
	_ = tmp

	values.Add("in", fmt.Sprint(req.In))

	r.URL.RawQuery = values.Encode()
	return nil
}

/************************************** NATSServer ******************************************/

// ServeNATS
func ServeNATS(conn *nats.Conn, srv *natsServer) error {

	echoSub, err := conn.QueueSubscribe("Echo.Echo", "Echo", srv.Echo.ServeMsg(conn))
	if err != nil {
		return err
	}
	_ = echoSub

	louderSub, err := conn.QueueSubscribe("Echo.Louder", "Echo", srv.Louder.ServeMsg(conn))
	if err != nil {
		return err
	}
	_ = louderSub

	loudergetSub, err := conn.QueueSubscribe("Echo.LouderGet", "Echo", srv.LouderGet.ServeMsg(conn))
	if err != nil {
		return err
	}
	_ = loudergetSub

	return nil

}

// MakeNATSServer makes a set of endpoints available as a NATS EchoServer.
func MakeNATSServer(endpoints Endpoints, options ...natstransport.SubscriberOption) *natsServer {
	serverOptions := []natstransport.SubscriberOption{
		// grpctransport.ServerBefore(GRPCMetadataToContext),
	}
	serverOptions = append(serverOptions, options...)
	// echo
	return &natsServer{

		Echo: natstransport.NewSubscriber(
			endpoints.EchoEndpoint,
			DecodeNATSEchoRequest,
			// EncodeNATSEchoResponse,
			EncodeNATSGenericResponse,
			serverOptions...,
		),
		Louder: natstransport.NewSubscriber(
			endpoints.LouderEndpoint,
			DecodeNATSLouderRequest,
			// EncodeNATSLouderResponse,
			EncodeNATSGenericResponse,
			serverOptions...,
		),
		LouderGet: natstransport.NewSubscriber(
			endpoints.LouderGetEndpoint,
			DecodeNATSLouderGetRequest,
			// EncodeNATSLouderGetResponse,
			EncodeNATSGenericResponse,
			serverOptions...,
		),
	}
}

// natsServer implements the EchoServer interface
type natsServer struct {
	Echo      *natstransport.Subscriber
	Louder    *natstransport.Subscriber
	LouderGet *natstransport.Subscriber
}

// Server Decode

func DecodeNATSEchoRequest(ctx context.Context, msg *nats.Msg) (interface{}, error) {
	var req EchoRequest
	if err := json.Unmarshal(msg.Data, &req); err != nil {
		return nil, err
	}
	return &req, nil
}

func DecodeNATSLouderRequest(ctx context.Context, msg *nats.Msg) (interface{}, error) {
	var req LouderRequest
	if err := json.Unmarshal(msg.Data, &req); err != nil {
		return nil, err
	}
	return &req, nil
}

func DecodeNATSLouderGetRequest(ctx context.Context, msg *nats.Msg) (interface{}, error) {
	var req LouderRequest
	if err := json.Unmarshal(msg.Data, &req); err != nil {
		return nil, err
	}
	return &req, nil
}

// Server Encode

// EncodeNATSGenericResponse is a transport/nats.EncodeResponseFunc that encodes
// JSON object to the subscriber reply. Many JSON-over services can use it as
// a sensible default.
func EncodeNATSGenericResponse(ctx context.Context, reply string, nc *nats.Conn, response interface{}) error {
	return natstransport.EncodeJSONResponse(ctx, reply, nc, response)
}

/************************************** NATSClient ******************************************/

// NewNATSClient returns an service backed by a nats client connection. It is the
// responsibility of the caller to dial, and later close, the connection.
func NewNATSClient(conn *nats.Conn, options ...natstransport.PublisherOption) (EchoServer, error) {
	var echoEndpoint endpoint.Endpoint
	{
		echoEndpoint = natstransport.NewPublisher(
			conn,
			"Echo.Echo",
			EncodeNATSGenericRequest,
			DecodeNATSEchoResponse,
			options...,
		).Endpoint()
	}

	var louderEndpoint endpoint.Endpoint
	{
		louderEndpoint = natstransport.NewPublisher(
			conn,
			"Echo.Louder",
			EncodeNATSGenericRequest,
			DecodeNATSLouderResponse,
			options...,
		).Endpoint()
	}

	var loudergetEndpoint endpoint.Endpoint
	{
		loudergetEndpoint = natstransport.NewPublisher(
			conn,
			"Echo.LouderGet",
			EncodeNATSGenericRequest,
			DecodeNATSLouderGetResponse,
			options...,
		).Endpoint()
	}

	return Endpoints{
		EchoEndpoint:      echoEndpoint,
		LouderEndpoint:    louderEndpoint,
		LouderGetEndpoint: loudergetEndpoint,
	}, nil
}

// NATS Client Decode

// DecodeNATSEchoResponse is a transport/nats.DecodeResponseFunc that converts a
// nats.Msg to a user-domain echo response. Primarily useful in a client.
func DecodeNATSEchoResponse(ctx context.Context, msg *nats.Msg) (interface{}, error) {
	// if err := json.Unmarshal(msg.Data, &errResponse); err != nil {
	// 	return nil, err
	// }
	// if errResponse.Error != nil && errResponse.Error.Code == "_internal_" {
	// 	return nil, errors.New(errResponse.Error.Message)
	// }
	var resp EchoResponse
	if err := json.Unmarshal(msg.Data, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// DecodeNATSLouderResponse is a transport/nats.DecodeResponseFunc that converts a
// nats.Msg to a user-domain louder response. Primarily useful in a client.
func DecodeNATSLouderResponse(ctx context.Context, msg *nats.Msg) (interface{}, error) {
	// if err := json.Unmarshal(msg.Data, &errResponse); err != nil {
	// 	return nil, err
	// }
	// if errResponse.Error != nil && errResponse.Error.Code == "_internal_" {
	// 	return nil, errors.New(errResponse.Error.Message)
	// }
	var resp EchoResponse
	if err := json.Unmarshal(msg.Data, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// DecodeNATSLouderGetResponse is a transport/nats.DecodeResponseFunc that converts a
// nats.Msg to a user-domain louderget response. Primarily useful in a client.
func DecodeNATSLouderGetResponse(ctx context.Context, msg *nats.Msg) (interface{}, error) {
	// if err := json.Unmarshal(msg.Data, &errResponse); err != nil {
	// 	return nil, err
	// }
	// if errResponse.Error != nil && errResponse.Error.Code == "_internal_" {
	// 	return nil, errors.New(errResponse.Error.Message)
	// }
	var resp EchoResponse
	if err := json.Unmarshal(msg.Data, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// NATS Client Encode
// EncodeNATSGenericRequest is a transport/nats.EncodeRequestFunc that serializes the request as a
// JSON object to the Data of the Msg. Many JSON-over-NATS services can use it as
// a sensible default.
func EncodeNATSGenericRequest(ctx context.Context, msg *nats.Msg, request interface{}) error {
	return natstransport.EncodeJSONRequest(ctx, msg, request)
}
