// Code generated by baron. DO NOT EDIT.
// Rerunning baron will overwrite this file.
// Version: {{.Version}}
// Version Date: {{.VersionDate}}

package {{.PackageName}}

// This file contains methods to make individual endpoints from services,
// request and response types to serve those endpoints, as well as encoders and
// decoders for those types, for all of our supported transport serialization
// formats.

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"context"
	"strconv"
	"strings"
	"io"

	"github.com/gogo/protobuf/jsonpb"
	"github.com/gogo/protobuf/proto"
	"github.com/go-kit/kit/endpoint"
	"github.com/gorilla/mux"
	"github.com/pkg/errors"

	"google.golang.org/grpc/metadata"

	grpctransport "github.com/go-kit/kit/transport/grpc"
	httptransport "github.com/go-kit/kit/transport/http"
)

// Endpoints collects all of the endpoints that compose an add service. It's
// meant to be used as a helper struct, to collect all of the endpoints into a
// single parameter.
//
// In a server, it's useful for functions that need to operate on a per-endpoint
// basis. For example, you might pass an Endpoints to a function that produces
// an http.Handler, with each method (endpoint) wired up to a specific path. (It
// is probably a mistake in design to invoke the Service methods on the
// Endpoints struct in a server.)
//
// In a client, it's useful to collect individually constructed endpoints into a
// single type that implements the Service interface. For example, you might
// construct individual endpoints using transport/http.NewClient, combine them into an Endpoints, and return it to the caller as a Service.
type Endpoints struct {
{{range $i := .Service.Methods}}
	{{$i.Name}}Endpoint    endpoint.Endpoint
{{- end}}
}

// Endpoints
{{range $i := .Service.Methods}}
	func (e Endpoints) {{$i.Name}}(ctx context.Context, in *{{GoName $i.RequestType.Name}}) (*{{GoName $i.ResponseType.Name}}, error) {
		response, err := e.{{$i.Name}}Endpoint(ctx, in)
		if err != nil {
			return nil, err
		}
		return response.(*{{GoName $i.ResponseType.Name}}), nil
	}
{{end}}

// Make Endpoints
{{with $te := .}}
	{{range $i := $te.Service.Methods}}
		func Make{{$i.Name}}Endpoint(s {{$te.Service.Name}}Server) endpoint.Endpoint {
			return func(ctx context.Context, request interface{}) (response interface{}, err error) {
				req := request.(*{{GoName $i.RequestType.Name}})
				v, err := s.{{$i.Name}}(ctx, req)
				if err != nil {
					return nil, err
				}
				return v, nil
			}
		}
	{{end}}
{{end}}

// WrapAllExcept wraps each Endpoint field of struct Endpoints with a
// go-kit/kit/endpoint.Middleware.
// Use this for applying a set of middlewares to every endpoint in the service.
// Optionally, endpoints can be passed in by name to be excluded from being wrapped.
// WrapAllExcept(middleware, "Status", "Ping")
func (e *Endpoints) WrapAllExcept(middleware endpoint.Middleware, excluded ...string) {
	included := map[string]struct{}{
		{{- range $i := .Service.Methods}}
			"{{$i.Name}}": {},
		{{- end}}
	}

	for _, ex := range excluded {
		if _, ok := included[ex]; !ok {
			panic(fmt.Sprintf("Excluded endpoint '%s' does not exist; see middlewares/endpoints.go", ex))
		}
		delete(included, ex)
	}

	for inc := range included {
		{{- range $i := .Service.Methods}}
			if inc == "{{$i.Name}}" {
				e.{{$i.Name}}Endpoint = middleware(e.{{$i.Name}}Endpoint)
			}
		{{- end}}
	}
}

// LabeledMiddleware will get passed the endpoint name when passed to
// WrapAllLabeledExcept, this can be used to write a generic metrics
// middleware which can send the endpoint name to the metrics collector.
type LabeledMiddleware func(string, endpoint.Endpoint) endpoint.Endpoint

// WrapAllLabeledExcept wraps each Endpoint field of struct Endpoints with a
// LabeledMiddleware, which will receive the name of the endpoint. See
// LabeldMiddleware. See method WrapAllExept for details on excluded
// functionality.
func (e *Endpoints) WrapAllLabeledExcept(middleware func(string, endpoint.Endpoint) endpoint.Endpoint, excluded ...string) {
	included := map[string]struct{}{
		{{- range $i := .Service.Methods}}
			"{{$i.Name}}": {},
		{{- end}}
	}

	for _, ex := range excluded {
		if _, ok := included[ex]; !ok {
			panic(fmt.Sprintf("Excluded endpoint '%s' does not exist; see middlewares/endpoints.go", ex))
		}
		delete(included, ex)
	}

	for inc := range included {
		{{- range $i := .Service.Methods}}
			if inc == "{{$i.Name}}" {
				e.{{$i.Name}}Endpoint = middleware("{{$i.Name}}", e.{{$i.Name}}Endpoint)
			}
		{{- end}}
	}
}

// GRPCServer

// MakeGRPCServer makes a set of endpoints available as a gRPC {{.Service.Name}}Server.
func MakeGRPCServer(endpoints Endpoints, options ...grpctransport.ServerOption) {{.Service.Name}}Server {
	serverOptions := []grpctransport.ServerOption{
		grpctransport.ServerBefore(metadataToContext),
	}
	serverOptions = append(serverOptions, options...)
	return &grpcServer{
	// {{ ToLower .Service.Name }}
	{{range $i := .Service.Methods}}
		{{ToLower $i.Name}}: grpctransport.NewServer(
			endpoints.{{$i.Name}}Endpoint,
			DecodeGRPC{{$i.Name}}Request,
			EncodeGRPC{{$i.Name}}Response,
			serverOptions...,
		),
	{{- end}}
	}
}

// grpcServer implements the {{GoName .Service.Name}}Server interface
type grpcServer struct {
{{range $i := .Service.Methods}}
	{{ToLower $i.Name}}   grpctransport.Handler
{{- end}}
}

// Methods for grpcServer to implement {{GoName .Service.Name}}Server interface
{{range $i := .Service.Methods}}
func (s *grpcServer) {{GoName $i.Name}}(ctx context.Context, req *{{GoName $i.RequestType.Name}}) (*{{GoName $i.ResponseType.Name}}, error) {
	_, rep, err := s.{{ToLower $i.Name}}.ServeGRPC(ctx, req)
	if err != nil {
		return nil, err
	}
	return rep.(*{{GoName $i.ResponseType.Name}}), nil
}
{{end}}

// Server Decode
{{range $i := .Service.Methods}}
// DecodeGRPC{{$i.Name}}Request is a transport/grpc.DecodeRequestFunc that converts a
// gRPC {{ToLower $i.Name}} request to a user-domain {{ToLower $i.Name}} request. Primarily useful in a server.
func DecodeGRPC{{$i.Name}}Request(_ context.Context, grpcReq interface{}) (interface{}, error) {
	req := grpcReq.(*{{GoName $i.RequestType.Name}})
	return req, nil
}
{{end}}

// Server Encode
{{range $i := .Service.Methods}}
// EncodeGRPC{{$i.Name}}Response is a transport/grpc.EncodeResponseFunc that converts a
// user-domain {{ToLower $i.Name}} response to a gRPC {{ToLower $i.Name}} reply. Primarily useful in a server.
func EncodeGRPC{{$i.Name}}Response(_ context.Context, response interface{}) (interface{}, error) {
	resp := response.(*{{GoName $i.ResponseType.Name}})
	return resp, nil
}
{{end}}

// Helpers

func metadataToContext(ctx context.Context, md metadata.MD) context.Context {
	for k, v := range md {
		if v != nil {
			// The key is added both in metadata format (k) which is all lower
			// and the http.CanonicalHeaderKey of the key so that it can be
			// accessed in either format
			ctx = context.WithValue(ctx, k, v[0])
			ctx = context.WithValue(ctx, http.CanonicalHeaderKey(k), v[0])
		}
	}

	return ctx
}

// HTTPServer

const contentType = "application/json; charset=utf-8"

// MakeHTTPHandler returns a handler that makes a set of endpoints available
// on predefined paths.
func MakeHTTPHandler(endpoints Endpoints, options ...httptransport.ServerOption) http.Handler {
	{{- if .HTTPHelper.Methods}}
		serverOptions := []httptransport.ServerOption{
			httptransport.ServerBefore(headersToContext),
			httptransport.ServerErrorEncoder(errorEncoder),
			httptransport.ServerAfter(httptransport.SetContentType(contentType)),
		}
		serverOptions = append(serverOptions, options...)
	{{- end }}
	m := mux.NewRouter()

	{{range $method := .HTTPHelper.Methods}}
		{{range $binding := $method.Bindings}}
			m.Methods("{{$binding.Verb | ToUpper}}").Path("{{$binding.PathTemplate}}").Handler(httptransport.NewServer(
				endpoints.{{$method.Name}}Endpoint,
				DecodeHTTP{{$binding.Label}}Request,
				EncodeHTTPGenericResponse,
				serverOptions...,
			))
		{{- end}}
	{{- end}}
	return m
}

// ErrorEncoder writes the error to the ResponseWriter, by default a content
// type of application/json, a body of json with key "error" and the value
// error.Error(), and a status code of 500. If the error implements Headerer,
// the provided headers will be applied to the response. If the error
// implements json.Marshaler, and the marshaling succeeds, the JSON encoded
// form of the error will be used. If the error implements StatusCoder, the
// provided StatusCode will be used instead of 500.
func errorEncoder(_ context.Context, err error, w http.ResponseWriter) {
	body, _ := json.Marshal(errorWrapper{Error: err.Error()})
	if marshaler, ok := err.(json.Marshaler); ok {
		if jsonBody, marshalErr := marshaler.MarshalJSON(); marshalErr == nil {
			body = jsonBody
		}
	}
	w.Header().Set("Content-Type", contentType)
	if headerer, ok := err.(httptransport.Headerer); ok {
		for k := range headerer.Headers() {
			w.Header().Set(k, headerer.Headers().Get(k))
		}
	}
	code := http.StatusInternalServerError
	if sc, ok := err.(httptransport.StatusCoder); ok {
		code = sc.StatusCode()
	}
	w.WriteHeader(code)
	w.Write(body)
}

type errorWrapper struct {
	Error string ` + "`" + `json:"error"` + "`" + `
}

// httpError satisfies the Headerer and StatusCoder interfaces in
// package github.com/go-kit/kit/transport/http.
type httpError struct {
	error
	statusCode int
	headers    map[string][]string
}

func (h httpError) StatusCode() int {
	return h.statusCode
}

func (h httpError) Headers() http.Header {
	return h.headers
}

// Server Decode
{{range $method := .HTTPHelper.Methods}}
	{{range $binding := $method.Bindings}}
		{{$binding.GenServerDecode}}
	{{end}}
{{end}}

// EncodeHTTPGenericResponse is a transport/http.EncodeResponseFunc that encodes
// the response as JSON to the response writer. Primarily useful in a server.
func EncodeHTTPGenericResponse(_ context.Context, w http.ResponseWriter, response interface{}) error {
	marshaller := jsonpb.Marshaler{
		EmitDefaults: false,
		OrigName: true,
	}

	return marshaller.Marshal(w, response.(proto.Message))
}

// Helper functions

func headersToContext(ctx context.Context, r *http.Request) context.Context {
	for k := range r.Header {
		// The key is added both in http format (k) which has had
		// http.CanonicalHeaderKey called on it in transport as well as the
		// strings.ToLower which is the grpc metadata format of the key so
		// that it can be accessed in either format
		ctx = context.WithValue(ctx, k, r.Header.Get(k))
		ctx = context.WithValue(ctx, strings.ToLower(k), r.Header.Get(k))
	}

	// Tune specific change.
	// also add the request url
	ctx = context.WithValue(ctx, "request-url", r.URL.Path)
	ctx = context.WithValue(ctx, "transport", "HTTPJSON")

	return ctx
}


{{- with $binding := . -}}
	// DecodeHTTP{{$binding.Label}}Request is a transport/http.DecodeRequestFunc that
	// decodes a JSON-encoded {{ToLower $binding.Parent.Name}} request from the HTTP request
	// body. Primarily useful in a server.
	func DecodeHTTP{{$binding.Label}}Request(_ context.Context, r *http.Request) (interface{}, error) {
		defer r.Body.Close()
		var req {{GoName $binding.Parent.RequestType}}
		buf, err := ioutil.ReadAll(r.Body)
		if err != nil {
			return nil, errors.Wrapf(err, "cannot read body of http request")
		}
		if len(buf) > 0 {
			// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
			unmarshaller := jsonpb.Unmarshaler{
				AllowUnknownFields: true,
			}
			if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
				const size = 8196
				if len(buf) > size {
					buf = buf[:size]
				}
				return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
					http.StatusBadRequest,
					nil,
				}
			}
		}

		pathParams := mux.Vars(r)
		_ = pathParams

		queryParams := r.URL.Query()
		_ = queryParams

		{{range $field := $binding.Fields}}
			{{if ne $field.Location "body"}}
				{{$field.GenQueryUnmarshaler}}
			{{end}}
		{{end}}

		{{range $field := $binding.OneofFields}}
			{{if eq $field.Location "query"}}
				{{$field.GenQueryUnmarshaler}}
			{{end}}
		{{end}}
		return &req, err
	}
{{- end -}}
