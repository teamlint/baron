// Code generated by baron. DO NOT EDIT.
// Rerunning baron will overwrite this file.
// Version: {{.Version}}
// Version Date: {{.VersionDate}}

package {{.PackageName}}

// This file contains methods to make individual endpoints from services,
// request and response types to serve those endpoints, as well as encoders and
// decoders for those types, for all of our supported transport serialization
// formats.

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strconv"
	"strings"

	"github.com/go-kit/kit/endpoint"
	"github.com/gogo/protobuf/jsonpb"
	"github.com/gogo/protobuf/proto"
	"github.com/gorilla/mux"
	"github.com/pkg/errors"
	{{if eq .Config.Transport "all" "nats" }}
	"github.com/nats-io/nats.go"
	{{end}}
	{{if eq .Config.Transport "all" "grpc" }}
	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
	{{end}}
	{{if eq .Config.Transport "all" "grpc" }}
	grpctransport "github.com/go-kit/kit/transport/grpc"
	{{end}}
	httptransport "github.com/go-kit/kit/transport/http"
	{{if eq .Config.Transport "all" "nats" }}
	natstransport "github.com/go-kit/kit/transport/nats"
	{{end}}
)


var (
	_ = fmt.Sprint
	_ = bytes.Compare
	_ = strconv.Atoi
	_ = httptransport.NewServer
	_ = ioutil.NopCloser
	_ = io.Copy
	_ = errors.Wrap
)

/************************************** Endpoints ******************************************/

// In a server, it's useful for functions that need to operate on a per-endpoint
// basis. For example, you might pass an Endpoints to a function that produces
// an http.Handler, with each method (endpoint) wired up to a specific path. (It
// is probably a mistake in design to invoke the Service methods on the
// Endpoints struct in a server.)
//
// In a client, it's useful to collect individually constructed endpoints into a
// single type that implements the Service interface. For example, you might
// construct individual endpoints using transport/http.NewClient, combine them into an Endpoints, and return it to the caller as a Service.
type Endpoints struct {
{{range $i := .Service.Methods}}
	{{$i.Name}}Endpoint    endpoint.Endpoint
{{- end}}
}

// Endpoints
{{range $i := .Service.Methods}}
	func (e Endpoints) {{$i.Name}}(ctx context.Context, in *{{GoName $i.RequestType.Name}}) (*{{GoName $i.ResponseType.Name}}, error) {
		response, err := e.{{$i.Name}}Endpoint(ctx, in)
		if err != nil {
			return nil, err
		}
		return response.(*{{GoName $i.ResponseType.Name}}), nil
	}
{{end}}

// Make Endpoints
{{with $te := .}}
	{{range $i := $te.Service.Methods}}
		func Make{{$i.Name}}Endpoint(s {{$te.Service.Name}}Server) endpoint.Endpoint {
			return func(ctx context.Context, request interface{}) (response interface{}, err error) {
				req := request.(*{{GoName $i.RequestType.Name}})
				v, err := s.{{$i.Name}}(ctx, req)
				if err != nil {
					return nil, err
				}
				return v, nil
			}
		}
	{{end}}
{{end}}

// WrapAllExcept wraps each Endpoint field of struct Endpoints with a
// go-kit/kit/endpoint.Middleware.
// Use this for applying a set of middlewares to every endpoint in the service.
// Optionally, endpoints can be passed in by name to be excluded from being wrapped.
// WrapAllExcept(middleware, "Status", "Ping")
func (e *Endpoints) WrapAllExcept(middleware endpoint.Middleware, excluded ...string) {
	included := map[string]struct{}{
		{{- range $i := .Service.Methods}}
			"{{$i.Name}}": {},
		{{- end}}
	}

	for _, ex := range excluded {
		if _, ok := included[ex]; !ok {
			panic(fmt.Sprintf("Excluded endpoint '%s' does not exist; see middlewares/endpoints.go", ex))
		}
		delete(included, ex)
	}

	for inc := range included {
		{{- range $i := .Service.Methods}}
			if inc == "{{$i.Name}}" {
				e.{{$i.Name}}Endpoint = middleware(e.{{$i.Name}}Endpoint)
			}
		{{- end}}
	}
}

// LabeledMiddleware will get passed the endpoint name when passed to
// WrapAllLabeledExcept, this can be used to write a generic metrics
// middleware which can send the endpoint name to the metrics collector.
type LabeledMiddleware func(string, endpoint.Endpoint) endpoint.Endpoint

// WrapAllLabeledExcept wraps each Endpoint field of struct Endpoints with a
// LabeledMiddleware, which will receive the name of the endpoint. See
// LabeldMiddleware. See method WrapAllExept for details on excluded
// functionality.
func (e *Endpoints) WrapAllLabeledExcept(middleware func(string, endpoint.Endpoint) endpoint.Endpoint, excluded ...string) {
	included := map[string]struct{}{
		{{- range $i := .Service.Methods}}
			"{{$i.Name}}": {},
		{{- end}}
	}

	for _, ex := range excluded {
		if _, ok := included[ex]; !ok {
			panic(fmt.Sprintf("Excluded endpoint '%s' does not exist; see middlewares/endpoints.go", ex))
		}
		delete(included, ex)
	}

	for inc := range included {
		{{- range $i := .Service.Methods}}
			if inc == "{{$i.Name}}" {
				e.{{$i.Name}}Endpoint = middleware("{{$i.Name}}", e.{{$i.Name}}Endpoint)
			}
		{{- end}}
	}
}
{{if eq .Config.Transport "all" "grpc" }}
/************************************** GRPCServer ******************************************/

// MakeGRPCServer makes a set of endpoints available as a gRPC {{.Service.Name}}Server.
func MakeGRPCServer(endpoints Endpoints, options ...grpctransport.ServerOption) {{.Service.Name}}Server {
	serverOptions := []grpctransport.ServerOption{
		grpctransport.ServerBefore(GRPCMetadataToContext),
	}
	serverOptions = append(serverOptions, options...)
	// {{ ToLower .Service.Name }}
	return &grpcServer{
	{{range $i := .Service.Methods}}
		{{ToLower $i.Name}}: grpctransport.NewServer(
			endpoints.{{$i.Name}}Endpoint,
			DecodeGRPC{{$i.Name}}Request,
			EncodeGRPC{{$i.Name}}Response,
			serverOptions...,
		),
	{{- end}}
	}
}

// grpcServer implements the {{GoName .Service.Name}}Server interface
type grpcServer struct {
{{range $i := .Service.Methods}}
	{{ToLower $i.Name}}   grpctransport.Handler
{{- end}}
}

// Methods for grpcServer to implement {{GoName .Service.Name}}Server interface
{{range $i := .Service.Methods}}
func (s *grpcServer) {{GoName $i.Name}}(ctx context.Context, req *{{GoName $i.RequestType.Name}}) (*{{GoName $i.ResponseType.Name}}, error) {
	_, rep, err := s.{{ToLower $i.Name}}.ServeGRPC(ctx, req)
	if err != nil {
		return nil, err
	}
	return rep.(*{{GoName $i.ResponseType.Name}}), nil
}
{{end}}

// Server Decode
{{range $i := .Service.Methods}}
// DecodeGRPC{{$i.Name}}Request is a transport/grpc.DecodeRequestFunc that converts a
// gRPC {{ToLower $i.Name}} request to a user-domain {{ToLower $i.Name}} request. Primarily useful in a server.
func DecodeGRPC{{$i.Name}}Request(_ context.Context, grpcReq interface{}) (interface{}, error) {
	req := grpcReq.(*{{GoName $i.RequestType.Name}})
	return req, nil
}
{{end}}

// Server Encode
{{range $i := .Service.Methods}}
// EncodeGRPC{{$i.Name}}Response is a transport/grpc.EncodeResponseFunc that converts a
// user-domain {{ToLower $i.Name}} response to a gRPC {{ToLower $i.Name}} reply. Primarily useful in a server.
func EncodeGRPC{{$i.Name}}Response(_ context.Context, response interface{}) (interface{}, error) {
	resp := response.(*{{GoName $i.ResponseType.Name}})
	return resp, nil
}
{{end}}

// Helpers

func GRPCMetadataToContext(ctx context.Context, md metadata.MD) context.Context {
	for k, v := range md {
		if v != nil {
			// The key is added both in metadata format (k) which is all lower
			// and the http.CanonicalHeaderKey of the key so that it can be
			// accessed in either format
			ctx = context.WithValue(ctx, k, v[0])
			ctx = context.WithValue(ctx, http.CanonicalHeaderKey(k), v[0])
		}
	}

	return ctx
}

/************************************** GRPCClient ******************************************/

// NewGRPCClient returns an service backed by a gRPC client connection. It is the
// responsibility of the caller to dial, and later close, the connection.
func NewGRPCClient(conn *grpc.ClientConn, options ...grpctransport.ClientOption) ({{.Service.Name}}Server, error) {
	{{- with $te := .}}
		{{- with $pkgName := $te.PackageName}}
			{{- range $i := $te.Service.Methods}}
				var {{ToLower $i.Name}}Endpoint endpoint.Endpoint
				{
					{{ToLower $i.Name}}Endpoint = grpctransport.NewClient(
						conn,
						"{{$pkgName}}.{{$te.Service.Name}}",
						"{{$i.Name}}",
						EncodeGRPC{{$i.Name}}Request,
						DecodeGRPC{{$i.Name}}Response,
						{{GoName $i.ResponseType.Name}}{},
						options...,
					).Endpoint()
				}
			{{end}}
		{{end}}
	{{end}}

	return Endpoints{
	{{range $i := .Service.Methods -}}
		{{$i.Name}}Endpoint:    {{ToLower $i.Name}}Endpoint,
	{{end}}
	}, nil
}

// GRPC Client Decode
{{range $i := .Service.Methods}}
// DecodeGRPC{{$i.Name}}Response is a transport/grpc.DecodeResponseFunc that converts a
// gRPC {{ToLower $i.Name}} reply to a user-domain {{ToLower $i.Name}} response. Primarily useful in a client.
func DecodeGRPC{{$i.Name}}Response(_ context.Context, grpcReply interface{}) (interface{}, error) {
	reply := grpcReply.(*{{GoName $i.ResponseType.Name}})
	return reply, nil
}
{{end}}

// GRPC Client Encode
{{range $i := .Service.Methods}}
// EncodeGRPC{{$i.Name}}Request is a transport/grpc.EncodeRequestFunc that converts a
// user-domain {{ToLower $i.Name}} request to a gRPC {{ToLower $i.Name}} request. Primarily useful in a client.
func EncodeGRPC{{$i.Name}}Request(_ context.Context, request interface{}) (interface{}, error) {
	req := request.(*{{GoName $i.RequestType.Name}})
	return req, nil
}
{{end}}

// ContextValuesToGRPCMetadata is a grpctransport.ClientRequestFunc
func ContextValuesToGRPCMetadata(keys []string) grpctransport.ClientRequestFunc {
	return func(ctx context.Context, md *metadata.MD) context.Context {
		var pairs []string
		for _, k := range keys {
			if v, ok := ctx.Value(k).(string); ok {
				pairs = append(pairs, k, v)
			}
		}

		if pairs != nil {
			*md = metadata.Join(*md, metadata.Pairs(pairs...))
		}

		return ctx
	}
}
{{end}}
/************************************** HTTPServer ******************************************/

const contentType = "application/json; charset=utf-8"

// MakeHTTPHandler returns a handler that makes a set of endpoints available
// on predefined paths.
func MakeHTTPHandler(endpoints Endpoints, options ...httptransport.ServerOption) http.Handler {
	{{- if .HTTPHelper.Methods}}
		serverOptions := []httptransport.ServerOption{
			httptransport.ServerBefore(HTTPHeadersToContext),
			httptransport.ServerErrorEncoder(errorEncoder),
			httptransport.ServerAfter(httptransport.SetContentType(contentType)),
		}
		serverOptions = append(serverOptions, options...)
	{{- end }}
	m := mux.NewRouter()

	{{range $method := .HTTPHelper.Methods}}
		{{range $binding := $method.Bindings}}
			m.Methods("{{$binding.Verb | ToUpper}}").Path("{{$binding.PathTemplate}}").Handler(httptransport.NewServer(
				endpoints.{{$method.Name}}Endpoint,
				DecodeHTTP{{$binding.Label}}Request,
				EncodeHTTPGenericResponse,
				serverOptions...,
			))
		{{- end}}
	{{- end}}
	return m
}

// ErrorEncoder writes the error to the ResponseWriter, by default a content
// type of application/json, a body of json with key "error" and the value
// error.Error(), and a status code of 500. If the error implements Headerer,
// the provided headers will be applied to the response. If the error
// implements json.Marshaler, and the marshaling succeeds, the JSON encoded
// form of the error will be used. If the error implements StatusCoder, the
// provided StatusCode will be used instead of 500.
func errorEncoder(_ context.Context, err error, w http.ResponseWriter) {
	body, _ := json.Marshal(errorWrapper{Error: err.Error()})
	if marshaler, ok := err.(json.Marshaler); ok {
		if jsonBody, marshalErr := marshaler.MarshalJSON(); marshalErr == nil {
			body = jsonBody
		}
	}
	w.Header().Set("Content-Type", contentType)
	if headerer, ok := err.(httptransport.Headerer); ok {
		for k := range headerer.Headers() {
			w.Header().Set(k, headerer.Headers().Get(k))
		}
	}
	code := http.StatusInternalServerError
	if sc, ok := err.(httptransport.StatusCoder); ok {
		code = sc.StatusCode()
	}
	w.WriteHeader(code)
	w.Write(body)
}

func errorDecoder(buf []byte) error {
	var w errorWrapper
	if err := json.Unmarshal(buf, &w); err != nil {
		const size = 8196
		if len(buf) > size {
			buf = buf[:size]
		}
		return fmt.Errorf("response body '%s': cannot parse non-json request body", buf)
	}

	return errors.New(w.Error)
}

type errorWrapper struct {
	Error string `json:"error"`
}

// httpError satisfies the Headerer and StatusCoder interfaces in
// package github.com/go-kit/kit/transport/http.
type httpError struct {
	error
	statusCode int
	headers    map[string][]string
}

func (h httpError) StatusCode() int {
	return h.statusCode
}

func (h httpError) Headers() http.Header {
	return h.headers
}

// Server Decode
{{range $method := .HTTPHelper.Methods}}
	{{range $binding := $method.Bindings -}}
	// DecodeHTTP{{$binding.Label}}Request is a transport/http.DecodeRequestFunc that
	// decodes a JSON-encoded {{ToLower $binding.Parent.Name}} request from the HTTP request
	// body. Primarily useful in a server.
	func DecodeHTTP{{$binding.Label}}Request(_ context.Context, r *http.Request) (interface{}, error) {
		defer r.Body.Close()
		var req {{GoName $binding.Parent.RequestType}}
		buf, err := ioutil.ReadAll(r.Body)
		if err != nil {
			return nil, errors.Wrapf(err, "cannot read body of http request")
		}
		if len(buf) > 0 {
			// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
			unmarshaller := jsonpb.Unmarshaler{
				AllowUnknownFields: true,
			}
			if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
				const size = 8196
				if len(buf) > size {
					buf = buf[:size]
				}
				return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
					http.StatusBadRequest,
					nil,
				}
			}
		}

		pathParams := mux.Vars(r)
		_ = pathParams

		queryParams := r.URL.Query()
		_ = queryParams

		{{range $field := $binding.Fields}}
			{{if ne $field.Location "body"}}
				{{$field.GenQueryUnmarshaler}}
			{{end}}
		{{end}}

		{{range $field := $binding.OneofFields}}
			{{if eq $field.Location "query"}}
				{{$field.GenQueryUnmarshaler}}
			{{end}}
		{{end}}
		return &req, err
	}
	{{- end -}}
{{end}}

// EncodeHTTPGenericResponse is a transport/http.EncodeResponseFunc that encodes
// the response as JSON to the response writer. Primarily useful in a server.
func EncodeHTTPGenericResponse(_ context.Context, w http.ResponseWriter, response interface{}) error {
	marshaller := jsonpb.Marshaler{
		EmitDefaults: true,
		OrigName: true,
		EnumsAsInts:  true,
	}

	return marshaller.Marshal(w, response.(proto.Message))
}

// Helper functions

func HTTPHeadersToContext(ctx context.Context, r *http.Request) context.Context {
	for k := range r.Header {
		// The key is added both in http format (k) which has had
		// http.CanonicalHeaderKey called on it in transport as well as the
		// strings.ToLower which is the grpc metadata format of the key so
		// that it can be accessed in either format
		ctx = context.WithValue(ctx, k, r.Header.Get(k))
		ctx = context.WithValue(ctx, strings.ToLower(k), r.Header.Get(k))
	}

	// Tune specific change.
	// also add the request url
	ctx = context.WithValue(ctx, "request-url", r.URL.Path)
	ctx = context.WithValue(ctx, "transport", "HTTPJSON")

	return ctx
}

/************************************** HTTPClient ******************************************/

// NewHTTPClient returns a service backed by an HTTP server living at the remote
// instance. We expect instance to come from a service discovery system, so
// likely of the form "host:port".
func NewHTTPClient(instance string, options ...httptransport.ClientOption) ({{.Service.Name}}Server, error) {
	if !strings.HasPrefix(instance, "http") {
		instance = "http://" + instance
	}
	u, err := url.Parse(instance)
	if err != nil {
		return nil, err
	}
	_ = u

	{{if not .HTTPHelper.Methods -}}
		panic("No HTTP Endpoints, this client will not work, define bindings in your proto definition")
	{{- end}}

	{{range $method := .HTTPHelper.Methods}}
		{{ if $method.Bindings -}}
			{{ with $binding := index $method.Bindings 0 -}}
				var {{$binding.Label}}Endpoint endpoint.Endpoint
				{
					{{$binding.Label}}Endpoint = httptransport.NewClient(
						"{{$binding.Verb | ToUpper}}",
						copyURL(u, "{{$binding.BasePath}}"),
						EncodeHTTP{{$binding.Label}}Request,
						DecodeHTTP{{$method.Name}}Response,
						options...,
					).Endpoint()
				}
			{{- end}}
		{{- end}}
	{{- end}}

	return Endpoints{
	{{range $method := .HTTPHelper.Methods -}}
		{{ if $method.Bindings -}}
			{{ with $binding := index $method.Bindings 0 -}}
				{{$method.Name}}Endpoint:    {{$binding.Label}}Endpoint,
			{{end}}
		{{- end}}
	{{- end}}
	}, nil
}

func copyURL(base *url.URL, path string) *url.URL {
	next := *base
	next.Path = path
	return &next
}

// CtxValuesToSend configures the http client to pull the specified keys out of
// the context and add them to the http request as headers.  Note that keys
// will have net/http.CanonicalHeaderKey called on them before being send over
// the wire and that is the form they will be available in the server context.
func CtxValuesToSend(keys ...string) httptransport.ClientOption {
	return httptransport.ClientBefore(func(ctx context.Context, r *http.Request) context.Context {
		for _, k := range keys {
			if v, ok := ctx.Value(k).(string); ok {
				r.Header.Set(k, v)
			}
		}
		return ctx
	})
}


// HTTP Client Decode
{{range $method := .HTTPHelper.Methods}}
	// DecodeHTTP{{$method.Name}}Response is a transport/http.DecodeResponseFunc that decodes
	// a JSON-encoded {{GoName $method.ResponseType}} response from the HTTP response body.
	// If the response has a non-200 status code, we will interpret that as an
	// error and attempt to decode the specific error message from the response
	// body. Primarily useful in a client.
	func DecodeHTTP{{$method.Name}}Response(_ context.Context, r *http.Response) (interface{}, error) {
		defer r.Body.Close()
		buf, err := ioutil.ReadAll(r.Body)
		if err == io.EOF {
			return nil, errors.New("response http body empty")
		}
		if err != nil {
			return nil, errors.Wrap(err, "cannot read http body")
		}

		if r.StatusCode != http.StatusOK {
			return nil, errors.Wrapf(errorDecoder(buf), "status code: '%d'", r.StatusCode)
		}

		var resp {{GoName $method.ResponseType}}
		if err = jsonpb.UnmarshalString(string(buf), &resp); err != nil {
			return nil, errorDecoder(buf)
		}

		return &resp, nil
	}
{{end}}

// HTTP Client Encode
{{range $method := .HTTPHelper.Methods}}
	{{- range $binding := $method.Bindings -}}
	// EncodeHTTP{{$binding.Label}}Request is a transport/http.EncodeRequestFunc
	// that encodes a {{ToLower $binding.Parent.Name}} request into the various portions of
	// the http request (path, query, and body).
	func EncodeHTTP{{$binding.Label}}Request(_ context.Context, r *http.Request, request interface{}) error {
		strval := ""
		_ = strval
		req := request.(*{{GoName $binding.Parent.RequestType}})
		_ = req

		r.Header.Set("transport", "HTTPJSON")
		r.Header.Set("request-url", r.URL.Path)

		// Set the path parameters
		path := strings.Join([]string{
		{{- range $section := $binding.PathSections}}
			{{$section}},
		{{- end}}
		}, "/")
		u, err := url.Parse(path)
		if err != nil {
			return errors.Wrapf(err, "couldn't unmarshal path %q", path)
		}
		r.URL.RawPath = u.RawPath
		r.URL.Path = u.Path

		// Set the query parameters
		values := r.URL.Query()
		var tmp []byte
		_ = tmp
		{{- range $field := $binding.Fields }}
			{{- if eq $field.Location "query"}}
				{{if and $field.Repeated $field.IsBaseType}}
					{{- if (Contains $field.GoType "[]string")}}
					values["{{$field.QueryParamName}}"] = req.{{$field.CamelName}}
					{{- else}}
					for _, v := range req.{{$field.CamelName}} {
						values.Add("{{$field.QueryParamName}}", fmt.Sprint(v))
					}
					{{- end}}
				{{else if or (not $field.IsBaseType) $field.Repeated}}
					tmp, err = json.Marshal(req.{{$field.CamelName}})
					if err != nil {
						return errors.Wrap(err, "failed to marshal req.{{$field.CamelName}}")
					}
					strval = string(tmp)
					values.Add("{{$field.QueryParamName}}", strval)
				{{else}}
					values.Add("{{$field.QueryParamName}}", fmt.Sprint(req.{{$field.CamelName}}))
				{{- end }}
			{{- end }}
		{{- end}}
		{{- range $oneof := $binding.OneofFields }}
			{{- if eq $oneof.Location "query"}}
				{{- range $option := $oneof.Options }}
					{{if or (not $option.IsBaseType) $option.Repeated}}
						if val := req.Get{{$option.Name}}(); val != {{$option.ZeroValue}} {
							tmp, err = json.Marshal(req.Get{{$option.Name}}())
							if err != nil {
								return errors.Wrap(err, "failed to marshal req.Get{{$option.Name}}()")
							}
							strval = string(tmp)
							values.Add("{{$option.QueryParamName}}", strval)
						}
					{{else}}
						if val := req.Get{{$option.Name}}(); val != {{$option.ZeroValue}} {
							values.Add("{{$option.QueryParamName}}", fmt.Sprint(val))
						}
					{{- end }}
				{{- end }}
			{{- end }}
		{{- end}}

		r.URL.RawQuery = values.Encode()

		{{- if ne $binding.Verb "get" }}
		// Set the body parameters
		var buf bytes.Buffer
		toRet := request.(*{{GoName $binding.Parent.RequestType}})
		{{- range $field := $binding.Fields -}}
			{{if eq $field.Location "body"}}
				{{/* Only set the fields which should be in the body, so all
				others will be omitted due to emptiness */}}
				toRet.{{$field.CamelName}} = req.{{$field.CamelName}}
			{{end}}
		{{- end }}
		encoder := json.NewEncoder(&buf)
		encoder.SetEscapeHTML(false)
		if err := encoder.Encode(toRet); err != nil {
			return errors.Wrapf(err, "couldn't encode body as json %v", toRet)
		}
		r.Body = ioutil.NopCloser(&buf)
		{{- end }}
		return nil
	}
	{{- end -}}
{{end}}
{{if eq .Config.Transport "all" "nats" }}
/************************************** NATSServer ******************************************/

// ServeNATS 
func ServeNATS(conn *nats.Conn, srv *natsServer) error {
{{with $te := .}}
	{{- range $i := $te.Service.Methods}}
		{{ToLower $i.Name}}Sub, err := conn.QueueSubscribe("{{$te.Service.Name}}.{{$i.Name}}", "{{$te.Service.Name}}", srv.{{$i.Name}}.ServeMsg(conn))
		if err != nil {
			return err
		}
		_ = {{ToLower $i.Name}}Sub
	{{end}}
	return nil
{{end}}
}

// MakeNATSServer makes a set of endpoints available as a NATS {{.Service.Name}}Server.
func MakeNATSServer(endpoints Endpoints, options ...natstransport.SubscriberOption) *natsServer {
	serverOptions := []natstransport.SubscriberOption{
		// grpctransport.ServerBefore(GRPCMetadataToContext),
	}
	serverOptions = append(serverOptions, options...)
	// {{ ToLower .Service.Name }}
	return &natsServer{
	{{range $i := .Service.Methods}}
		{{$i.Name}}: natstransport.NewSubscriber(
			endpoints.{{$i.Name}}Endpoint,
			DecodeNATS{{$i.Name}}Request,
			// EncodeNATS{{$i.Name}}Response,
			EncodeNATSGenericResponse,
			serverOptions...,
		),
	{{- end}}
	}
}

// natsServer implements the {{GoName .Service.Name}}Server interface
type natsServer struct {
{{range $i := .Service.Methods}}
	{{$i.Name}}   *natstransport.Subscriber
{{- end}}
}

// Server Decode
{{range $i := .Service.Methods}}
func DecodeNATS{{.Name}}Request(ctx context.Context, msg *nats.Msg) (interface{}, error) {
	var req {{GoName $i.RequestType.Name}}
	if err := json.Unmarshal(msg.Data, &req); err != nil {
		return nil, err
	}
	return &req, nil
}
{{end}}

// Server Encode

// EncodeNATSGenericResponse is a transport/nats.EncodeResponseFunc that encodes
// JSON object to the subscriber reply. Many JSON-over services can use it as
// a sensible default.
func EncodeNATSGenericResponse(ctx context.Context, reply string, nc *nats.Conn, response interface{}) error {
	return natstransport.EncodeJSONResponse(ctx, reply, nc, response)
}

/************************************** NATSClient ******************************************/

// NewNATSClient returns an service backed by a nats client connection. It is the
// responsibility of the caller to dial, and later close, the connection.
func NewNATSClient(conn *nats.Conn, options ...natstransport.PublisherOption) ({{.Service.Name}}Server, error) {
	{{- with $te := .}}
		{{- range $i := $te.Service.Methods}}
			var {{ToLower $i.Name}}Endpoint endpoint.Endpoint
			{
				{{ToLower $i.Name}}Endpoint = natstransport.NewPublisher(
					conn,
					"{{$te.Service.Name}}.{{$i.Name}}",
					EncodeNATSGenericRequest,
					DecodeNATS{{$i.Name}}Response,
					options...,
				).Endpoint()
			}
		{{end}}
	{{end}}

	return Endpoints{
	{{range $i := .Service.Methods -}}
		{{$i.Name}}Endpoint:    {{ToLower $i.Name}}Endpoint,
	{{end}}
	}, nil
}

// NATS Client Decode
{{range $i := .Service.Methods}}
// DecodeNATS{{$i.Name}}Response is a transport/nats.DecodeResponseFunc that converts a
// nats.Msg to a user-domain {{ToLower $i.Name}} response. Primarily useful in a client.
func DecodeNATS{{$i.Name}}Response(ctx context.Context, msg *nats.Msg ) (interface{}, error) {
	// if err := json.Unmarshal(msg.Data, &errResponse); err != nil {
	// 	return nil, err
	// }
	// if errResponse.Error != nil && errResponse.Error.Code == "_internal_" {
	// 	return nil, errors.New(errResponse.Error.Message)
	// }
	var resp {{GoName $i.ResponseType.Name}}
	if err := json.Unmarshal(msg.Data, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}
{{end}}

// NATS Client Encode
// EncodeNATSGenericRequest is a transport/nats.EncodeRequestFunc that serializes the request as a
// JSON object to the Data of the Msg. Many JSON-over-NATS services can use it as
// a sensible default.
func EncodeNATSGenericRequest(ctx context.Context, msg *nats.Msg, request interface{}) error {
	return natstransport.EncodeJSONRequest(ctx, msg, request)
}
{{end}}
